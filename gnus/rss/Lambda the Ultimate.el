;; -*- coding: utf-8-emacs; -*-
(setq nnrss-group-data '((40 (20954 30962 437151) "http://lambda-the-ultimate.org/node/4775" "Crowdsourced Enumeration Queries" nil "Mon, 08 Jul 2013 00:31:37 -0400" "<p >From \"<a href=\"https://amplab.cs.berkeley.edu/wp-content/uploads/2012/12/ICDE13_conf_full_690.pdf\">Crowdsourced Enumeration Queries</a>\" by Beth Trushkowsky, Tim Kraska, Michael J. Franklin, Purnamrita Sarkar. <b >ICDE 2013 best paper award</b>, and one of my recent favorites.</p>
<blockquote ><p >
Hybrid human/computer database systems promise<br >
to greatly expand the usefulness of query processing by incorpo-<br >
rating the crowd for data gathering and other tasks. Such systems<br >
raise many implementation questions. Perhaps the most funda-<br >
mental question is that the closed world assumption underlying<br >
relational query semantics does not hold in such systems. As a<br >
consequence the meaning of even simple queries can be called<br >
into question. Furthermore, query progress monitoring becomes<br >
difficult due to non-uniformities in the arrival of crowdsourced<br >
data and peculiarities of how people work in crowdsourcing<br >
systems. To address these issues, we develop statistical tools<br >
that enable users and systems developers to reason about query<br >
completeness. These tools can also help drive query execution<br >
and crowdsourcing strategies. We evaluate our techniques using<br >
experiments on a popular crowdsourcing platform
</p></blockquote>
<p >I've been playing with crowdsourcing function evaluation, and the above line of work shines: different types of human queries suggest different types of semantics. For example, <code >Select all states in the US</code> makes sense, while <code >select all ice cream flavors</code> has, arguably, a quantification error. The differences lead to fun stuff, such as distinct query plan optimizations for different human computations. I've found this style of thinking to guide my own recent implementation work. </p>
<p >The overall research field intersects many good topics: linguistics / NLP, query planning, language design, etc.</p>
<p >Pdf is <a href=\"https://amplab.cs.berkeley.edu/wp-content/uploads/2012/12/ICDE13_conf_full_690.pdf\">here</a>.</p>" nil nil "3d95c18b6f82260b266fdfe6b08b777d") (39 (20954 30962 436737) "http://lambda-the-ultimate.org/node/4774" "Cryptography DSL." nil "Sun, 07 Jul 2013 22:13:50 -0400" "<p >Lifted from a press release issued back in 2008. </p>
<blockquote ><p >
Cryptol is a domain specific language for the design,<br >
implementation and verification of cryptographic algorithms,<br >
developed over the past decade by Galois for the United States<br >
National Security Agency. It has been used successfully in a<br >
number of projects, and is also in use at Rockwell Collins, Inc.</p>
<p >     Domain-specific languages (DSLs) allow subject-matter experts to<br >
design solutions in using familiar concepts and<br >
constructs. Cryptol, as a DSL, allows domain experts in<br >
cryptography to design and implement cryptographic algorithms<br >
with a high degree of assurance in the correctness of their<br >
design, and at the same time, producing a high performance<br >
implementation of their algorithms.
</p></blockquote>
<p >http://corp.galois.com/cryptol/</p>
<p >Note: I am not in any way affiliated with Galois inc, and not, myself, a user of the Cryptol language.  I'm posting it because I thought LtU might find this an interesting thing to discuss. </p>" nil nil "05a238343910fceb8092960dde4f168e") (38 (20954 29023 461223) "http://lambda-the-ultimate.org/node/4775" "Crowdsourced Enumeration Queries" nil "Mon, 08 Jul 2013 00:31:37 -0400" "<p >From \"<a href=\"https://amplab.cs.berkeley.edu/wp-content/uploads/2012/12/ICDE13_conf_full_690.pdf\">Crowdsourced Enumeration Queries</a>\" by Beth Trushkowsky, Tim Kraska, Michael J. Franklin, Purnamrita Sarkar. <b >ICDE 2013 best paper award</b>, and one of my recent favorites.</p>
<blockquote ><p >
Hybrid human/computer database systems promise<br >
to greatly expand the usefulness of query processing by incorpo-<br >
rating the crowd for data gathering and other tasks. Such systems<br >
raise many implementation questions. Perhaps the most funda-<br >
mental question is that the closed world assumption underlying<br >
relational query semantics does not hold in such systems. As a<br >
consequence the meaning of even simple queries can be called<br >
into question. Furthermore, query progress monitoring becomes<br >
difficult due to non-uniformities in the arrival of crowdsourced<br >
data and peculiarities of how people work in crowdsourcing<br >
systems. To address these issues, we develop statistical tools<br >
that enable users and systems developers to reason about query<br >
completeness. These tools can also help drive query execution<br >
and crowdsourcing strategies. We evaluate our techniques using<br >
experiments on a popular crowdsourcing platform
</p></blockquote>
<p >I've been playing with crowdsourcing function evaluation, and the above line of work shines: different types of human queries suggest different types of semantics. For example, <code >Select all states in the US</code> makes sense, while <code >select all ice cream flavors</code> has, arguably, a quantification error. The differences lead to fun stuff, such as distinct query plan optimizations for different human computations. I've found this style of thinking to guide my own recent implementation work. </p>
<p >The overall research field intersects many good topics: linguistics / NLP, query planning, language design, etc.</p>
<p >Pdf is <a href=\"https://amplab.cs.berkeley.edu/wp-content/uploads/2012/12/ICDE13_conf_full_690.pdf\">here</a>.</p>" nil nil "e0b564970ae8156654cc728580e0f378") (37 (20954 29023 460800) "http://lambda-the-ultimate.org/node/4774" "Cryptography DSL." nil "Sun, 07 Jul 2013 22:13:50 -0400" "<p >Lifted from a press release issued back in 2008. </p>
<blockquote ><p >
Cryptol is a domain specific language for the design,<br >
implementation and verification of cryptographic algorithms,<br >
developed over the past decade by Galois for the United States<br >
National Security Agency. It has been used successfully in a<br >
number of projects, and is also in use at Rockwell Collins, Inc.</p>
<p >     Domain-specific languages (DSLs) allow subject-matter experts to<br >
design solutions in using familiar concepts and<br >
constructs. Cryptol, as a DSL, allows domain experts in<br >
cryptography to design and implement cryptographic algorithms<br >
with a high degree of assurance in the correctness of their<br >
design, and at the same time, producing a high performance<br >
implementation of their algorithms.
</p></blockquote>
<p >http://corp.galois.com/cryptol/</p>
<p >Note: I am not in any way affiliated with Galois inc, and not, myself, a user of the Cryptol language.  I'm posting it because I thought LtU might find this an interesting thing to discuss. </p>" nil nil "40f85c5ba692fae0e3cc2b6e106851a4") (36 (20949 25793 658968) "http://lambda-the-ultimate.org/node/4772" "Harlan (a high level language for general purpose GPU computing)" nil "Wed, 03 Jul 2013 03:21:39 -0400" "<p >Eric Holk has released the source to Harlan.</p>
<p >\"We propose a declarative approach to coordinating computation and data movement between CPU and GPU, through a domain-speciÔ¨Åc language that we called Harlan\"</p>
<p >Paper here : http://www.cs.indiana.edu/~eholk/papers/parco2011.pdf</p>
<p >Git here : https://github.com/eholk/harlan</p>" nil nil "6a2b37caa9c22f2ffc5b4e0188288385") (35 (20949 25793 658728) "http://lambda-the-ultimate.org/node/4771" "Constraint-Based Type Inference and Parametric Polymorphism" nil "Sat, 29 Jun 2013 21:04:05 -0400" "<p >An <a href=\"http://www.cs.berkeley.edu/~fateman/264/papers/sas94.pdf\">old paper</a> ('94) by Ole Agesen, abstract:</p>
<blockquote ><p >
Constraint-based analysis is a technique for inferring implementation types. Traditionally it has been described using mathematical formalisms. We explain it in a different and more intuitive way as a flow problem. The intuition is facilitated by a direct correspondence between run-time and analysis-time concepts.</p>
<p >Precise analysis of polymorphism is hard; several algorithms have been developed to cope with it. Focusing on parametric polymorphism and using the flow perspective, we analyze and compare these algorithms, for the first time directly characterizing when they succeed and fail.</p>
<p >Our study of the algorithms lead us to two conclusions. First, designing an algorithm that is either efficient or precise is easy, but designing an algorithm that is efficient and precise is hard. Second, to achieve efficiency and precision simultaneously, the analysis effort must be actively guided towards the areas of the program with the highest pay-off. We define a general class of algorithms that do this: the adaptive algorithms. The two most powerful of the five algorithms we study fall in this class.
</p></blockquote>" nil nil "7862a1297f69bbab8965f6786f90c371") (34 (20949 25793 658410) "http://lambda-the-ultimate.org/node/4769" "Dynamic inheritance?" nil "Sat, 29 Jun 2013 06:54:46 -0400" "<p >Consider class C that inherits from class B in a (statically) typed language. I would like to extend, at runtime, an instance of type B to type C:</p>
<pre >
B b = new B();
Assert(b is B);
b.Method(); // invokes B.Method()
extend b to C();  // partial constructor for C
Assert(b is B);
Assert(b is C);
b.Method(); // invokes C.Method() override
</pre><p >Is there any reason why this should not be allowed in terms of type safety? If not, what is it called and is there any language out there that supports this?</p>" nil nil "8b827b9c343c7038444a4d3fae76100b") (33 (20949 25793 658133) "http://lambda-the-ultimate.org/node/4768" "When will we all have effect systems?" nil "Wed, 26 Jun 2013 17:19:38 -0400" "<p >It seems effect types are things people want, but few languages have managed to reify them, make them something we can all use. (Like, in -- cough cough -- Java et. al.) Any thoughts on how/when it will get to be more mainstream? Good enough that you'd risk using in production (at least w/in a group that is a little on the cutting-edge)? What things should a decent effect system support? Not only null checks I hope. (I was wondering about, via 'pilud' list, is how to rigorously handle immutable/mutable conversion/interaction.) Or are we just stuck with monads and related transformer boilerplate (and confusion to people like me)?</p>
<ul >
<li ><a href=\"http://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf\">Effects in Idris</a> (esoteric).</li>
<li ><a href=\"http://math.andrej.com/eff/\">Eff</a> (in progress, academic).</li>
<li ><a href=\"http://disciple.ouroborus.net/\">DDC</a> (rip).</li>
<li ><a href=\"http://lambda-the-ultimate.org/deca\">Deca</a> for pointers (limited).</li>
<li ><a href=\"http://homepages.inf.ed.ac.uk/slindley/papers/corelinks.pdf\">Links and DBs</a> (limited).</li>
<li ><a href=\"http://www.psrg.csail.mit.edu/history/publications/Papers/fx91-report.pdf\">FX-91</a> back in the day (rip).</li>
</ul>" nil nil "ee8e1e7799907f58975c099eff16b085") (32 (20949 25793 657821) "http://lambda-the-ultimate.org/node/4767" "Are first-class environments enough?" nil "Fri, 21 Jun 2013 12:02:47 -0400" "<p >Everyone (e.g. in the <a href=\"/node/3861\">LtU discussion back from 2010</a>) seems to assume that first-class environments in a Scheme-like lexically scoped language are sufficient to implement all known module systems and then some. Still, it strikes me that implementing renaming of imported bindings (R[67]RS and Chicken <code >(rename)</code>, Racket <code >(rename-in)</code>) with just first-class environments is impossible <i >in the presence of mutability,</i> even if foreign code is forbidden from mutating things inside the module. Even <code >(only)</code>-style shadowing is impossible without built-in support specifically for it in addition to plain environment inheritance. Introducing all this into environment semantics makes the whole idea look much less clean than it initially did. So, is this better done with stronger things like first-class locations? Or am I missing something obvious?</p>
<p >There are suggestions that <a href=\"http://www.gnu.org/software/mit-scheme/\">MIT Scheme</a> indeed implements its module system using environments, but I couldn‚Äôt really understand how (and whether) it handles this issue. The description in the <a href=\"http://web.cs.wpi.edu/~jshutt/kernel.html\">Kernel</a> language report is the best reference I could get on the topic.</p>
<p >Finally, note that this question is orthogonal to whether mutating exported bindings is a good thing to do from the stylistic point of view. If a language has mutability and a module system, it‚Äôd better be consistent in how they interact ‚Äî a negative example here being the behaviour of bindings created with <code >from module import ...</code> in Python.</p>" nil nil "57d2776889545b6f08eba5d5c4e62157") (31 (20949 25793 657438) "http://lambda-the-ultimate.org/node/4766" "Lobster, a new programming language, just released." nil "Mon, 17 Jun 2013 21:11:40 -0400" "<p >Lobster ( http://strlen.com/lobster ) has been released on GitHub ( https://github.com/aardappel/lobster ). It is a language that could be general purpose, but currently is specifically targeting game programming, with built-in support for OpenGL / SDL / FreeType. </p>
<p >The language looks similar to Python at first glance, but really is its own blend of fun features: a syntax centering around making higher order functions & function values look & function as much as possible like built-in control structures (terse, and with non-local returns), coroutines, multi-methods, vector operations, optional types, optional immutability.</p>
<p >The design did not have any lofty goals of programming language research or innovation, instead, it indulges in simply being a fun language for the typical code written in it (small-medium games).</p>" nil nil "06110e48a77bb916018c408dad2a3a28") (30 (20949 25793 657178) "http://lambda-the-ultimate.org/node/4765" "Library vs. domain specific language" nil "Mon, 17 Jun 2013 09:11:13 -0400" "<p >I guess this question was already discussed here on LtU, but I did not find it.</p>
<p >When is it necessary and rewarding to design a domain specific language, instead of creating a library for some general purpose language? Is it just more convenient syntax? What are the aspects that should be taken into account on deciding this question?</p>" nil nil "35da9de4666825a3d43ea872c51ec497") (29 (20949 25793 656949) "http://lambda-the-ultimate.org/node/4764" "A New Kind of Type System" nil "Sat, 15 Jun 2013 22:15:53 -0400" "<p >I've been working on this <a href=\"http://mcdirmid.github.io/2013/06/14/a-new-kind-of-type-system/\">note</a> to describe the type system I've been working on that collects many of the ideas I've been working on (see <a href=\"http://lambda-the-ultimate.org/node/4431\">here</a>, <a href=\"http://lambda-the-ultimate.org/node/4493\">here</a> and <a href=\"\">here</a>, and <a href=\"http://lambda-the-ultimate.org/node/4660\">here</a>). Now that I actually have something fairly complete, feedback would be appreciated. I'm currently implementing this in my <a href=\"http://lambda-the-ultimate.org/node/4715\">live programming</a> work and it will hopefully be in my next prototype, though the ideas are relatively unrelated so far. Abstract:</p>
<blockquote ><p >
This note introduces a novel type system that is static, annotation free, and object-oriented with class-like mixin-style traits. Inference in this YinYang type system diverges significantly from Hindley-Milner by computing graphs of assignment relationships rather than principal types, hiding values and preserving connectivity in encapsulated graphs. Inferred types are then useful not only for checking purposes, but also in allowing code completion to specify program functionality in a relaxed order.
</p></blockquote>
<p >Again, the note is hosted <a href=\"http://mcdirmid.github.io/2013/06/14/a-new-kind-of-type-system/\">here</a> on GitHub.</p>" nil nil "590a8611887e2e7bb21a2b7947659263") (28 (20949 25793 656634) "http://lambda-the-ultimate.org/node/4763" "a Scientific Basis for Visual Notations" nil "Fri, 14 Jun 2013 13:39:32 -0400" "<blockquote ><p >
<a href=\"http://www.ajilon.com.au/en-AU/news/Documents/News_PDFs/100528_Dr_Daniel_Moody_Software_Engineering_Keynote.pdf\">This paper [pdf]</a> defines a set of principles for designing cognitively effective visual notations.
</p></blockquote>
<p >(i'd quote more but i can't copy and paste and i'm already tired of typing.)</p>" nil nil "01402acd26a9bb9175ac80ecc36c0f17") (27 (20949 25793 656430) "http://lambda-the-ultimate.org/node/4762" "Compile-time constraint solver?" nil "Thu, 13 Jun 2013 13:31:10 -0400" "<p >C's type system can be seen as a constraint checker; Haskell's as a constraint solver. If you had a general purpose constraint solver at compile-time what could you use it for other than type checking?</p>" nil nil "02d1b5f0d3468716646bab2ba7714b62") (26 (20949 25793 656162) "http://lambda-the-ultimate.org/node/4761" "Define it twice -- preemptive bughunting or waste of time?" nil "Mon, 10 Jun 2013 20:38:05 -0400" "<p >Suppose I allow multiple definitions of routines/classes in a programming language, with the caveat that anything multiply defined must have identical semantics (identical interface, identical results, identical effects if non functional) and different syntactic structure in every definition. </p>
<p >Then have the development environment (but probably not the runtime environment) run multiple copies of the program, synchronizing just before and after each call to the multiply-implemented routine or class. If different results/effects are detected by a comparison of the program states at return time, halt with an error message.  Clearly, if both (or all) implementations are supposed to have the same semantics, then when results/effects diverge, it is evidence that at least one has a bug.</p>
<p >It seems unlikely, though possible, that both would have the same bugs, leading to rare \"false positives\" in which the test suite completes without error despite a lurking bug.   False negatives however -- where the test suite halts with a comparison error despite the tested code having identical semantics, would be eliminated.  Every time the alarm goes up, there is definitely something wrong. </p>
<p >Refactoring would also be easier; when a new implementation is supposed to provide the same services to the rest of the program as the old one, you could run them simultaneously rather than serially through a test suite, and make sure that, in fact, they do. This would also mean you can add test cases spontaneously and run them parallel, rather than having to reconfigure your program (twice!) to test both implementations against each other on a new test case you add/find after the first run of testing. </p>
<p >A semi-random thought about development environments.  More a programmer convenience, perhaps, since you could do the test and comparison by hand as well,  but nevertheless an important complement to static analysis.  It would allow you to test things well beyond the ability of a typical type analysis to make sure that they are and do, in fact, what you want. </p>
<p >Anyone seen something similar, or is this actually an original idea?</p>" nil nil "5378804df55d57217e0d8b64a7908d1f") (25 (20949 25793 655747) "http://lambda-the-ultimate.org/node/4760" "A little comparison of some programming lanugages" nil "Sun, 09 Jun 2013 17:47:21 -0400" "<blockquote ><p >
<a href=\"http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/\">This post</a> evaluates the programming languages ATS, C#, Go, Haskell, OCaml, Python and Rust to try to decide which would be the best language in which to write 0install (which is currently implemented in Python). Hopefully it will also be interesting to anyone curious about these languages.
</p></blockquote>
<p >i thought the <a href=\"http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#safety\">\"safety\" portion</a> of the evaluation was particularly interesting.</p>
<p >(overall, i find the review depressing: there's no good programming language, i guess.)</p>" nil nil "eadc46f75348f188b2c5776237ed49f9") (24 (20949 25793 655490) "http://lambda-the-ultimate.org/node/4759" "So You are Thinking of Doing a PhD..." nil "Sun, 09 Jun 2013 11:11:53 -0400" "<p >On a lighthearted note, if you're considering pursuing a PhD you might want to take <a href=\"http://blog.prof.so/2013/06/test.html\">this simple test to see if you're a good candidate for this lifestyle.</p>" nil nil "6267e59bea3de35cb3cf17fe77c79220") (23 (20949 25793 655285) "http://lambda-the-ultimate.org/node/4758" "A discussion from the trenches." nil "Sat, 08 Jun 2013 17:49:13 -0400" "<p >Over at lwn there is an currently a <a href=\"https://lwn.net/Articles/553131/\">discussion</a> going on about the little things in programming languages that make a difference.  Commas, decimal points, braces, etc. </p>
<p >The content is subscriber only for the first week so won't be generally available until the June 16th. </p>" nil nil "1f088a1fd7f839439d1a734fa576bc5e") (22 (20949 25793 654992) "http://lambda-the-ultimate.org/node/4757" "CFP: ACM High Integrity Language Technology (HILT 2013) due July 6th; conference in Pittsburgh Nov. 10-14" nil "Thu, 06 Jun 2013 12:08:52 -0400" "<p >The deadline is July 6th (just a week away) for submitting papers to the annual ACM conference on High Integrity Language Technology (HILT 2013).  The conference will be in Pittsburgh November 10-14, in close proximity to the Software Engineering Institute and CMU.  We have four great keynotes/invited speakers for this conference (Jeannette Wing, Ed Clarke, John Goodenough, and Michael Whalen), several interesting tutorials (on SMT solvers, Model Checking, etc.), and we are expecting some great papers as well (so get cracking!).  </p>
<p >Conference website is:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013\">http://www.sigada.org/conf/hilt2013</a></p>
<p >PDF Call for papers is at:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf\">http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf</a></p>
<p >-Tucker Taft<br >
Program Chair, HILT 2013</p>" nil nil "c0af5e12078cdd4eff3ce3e2a70eee26") (21 (20947 56087 963948) "http://lambda-the-ultimate.org/node/4772" "Harlan (a high level language for general purpose GPU computing)" nil "Wed, 03 Jul 2013 03:21:39 -0400" "<p >Eric Holk has released the source to Harlan.</p>
<p >\"We propose a declarative approach to coordinating computation and data movement between CPU and GPU, through a domain-speciÔ¨Åc language that we called Harlan\"</p>
<p >Paper here : http://www.cs.indiana.edu/~eholk/papers/parco2011.pdf</p>
<p >Git here : https://github.com/eholk/harlan</p>" nil nil "50122e2fb2a7aad88b58d243dc788ba9") (20 (20945 14388 608105) "http://lambda-the-ultimate.org/node/4771" "Constraint-Based Type Inference and Parametric Polymorphism" nil "Sat, 29 Jun 2013 21:04:05 -0400" "<p >An <a href=\"http://www.cs.berkeley.edu/~fateman/264/papers/sas94.pdf\">old paper</a> ('94) by Ole Agesen, abstract:</p>
<blockquote ><p >
Constraint-based analysis is a technique for inferring implementation types. Traditionally it has been described using mathematical formalisms. We explain it in a different and more intuitive way as a flow problem. The intuition is facilitated by a direct correspondence between run-time and analysis-time concepts.</p>
<p >Precise analysis of polymorphism is hard; several algorithms have been developed to cope with it. Focusing on parametric polymorphism and using the flow perspective, we analyze and compare these algorithms, for the first time directly characterizing when they succeed and fail.</p>
<p >Our study of the algorithms lead us to two conclusions. First, designing an algorithm that is either efficient or precise is easy, but designing an algorithm that is efficient and precise is hard. Second, to achieve efficiency and precision simultaneously, the analysis effort must be actively guided towards the areas of the program with the highest pay-off. We define a general class of algorithms that do this: the adaptive algorithms. The two most powerful of the five algorithms we study fall in this class.
</p></blockquote>" nil nil "af80ea2628fc6dea32527f69134ce11b") (19 (20945 14388 607746) "http://lambda-the-ultimate.org/node/4769" "Dynamic inheritance?" nil "Sat, 29 Jun 2013 06:54:46 -0400" "<p >Consider class C that inherits from class B in a (statically) typed language. I would like to extend, at runtime, an instance of type B to type C:</p>
<pre >
B b = new B();
Assert(b is B);
b.Method(); // invokes B.Method()
extend b to C();  // partial constructor for C
Assert(b is B);
Assert(b is C);
b.Method(); // invokes C.Method() override
</pre><p >Is there any reason why this should not be allowed in terms of type safety? If not, what is it called and is there any language out there that supports this?</p>" nil nil "f69600a232744dfbb695ac612d511030") (18 (20941 17518 321866) "http://lambda-the-ultimate.org/node/4757" "CFP: ACM High Integrity Language Technology (HILT 2013) due July 6th; conference in Pittsburgh Nov. 10-14" nil "Thu, 06 Jun 2013 12:08:52 -0400" "<p >The deadline is July 6th (just a week away) for submitting papers to the annual ACM conference on High Integrity Language Technology (HILT 2013).  The conference will be in Pittsburgh November 10-14, in close proximity to the Software Engineering Institute and CMU.  We have four great keynotes/invited speakers for this conference (Jeannette Wing, Ed Clarke, John Goodenough, and Michael Whalen), several interesting tutorials (on SMT solvers, Model Checking, etc.), and we are expecting some great papers as well (so get cracking!).  </p>
<p >Conference website is:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013\">http://www.sigada.org/conf/hilt2013</a></p>
<p >PDF Call for papers is at:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf\">http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf</a></p>
<p >-Tucker Taft<br >
Program Chair, HILT 2013</p>" nil nil "12f735b871a572142f9774fe24f40b4f") (17 (20939 63904 844390) "http://lambda-the-ultimate.org/node/4768" "When will we all have effect systems?" nil "Wed, 26 Jun 2013 17:19:38 -0400" "<p >It seems effect types are things people want, but few languages have managed to reify them, make them something we can all use. (Like, in -- cough cough -- Java et. al.) Any thoughts on how/when it will get to be more mainstream? Good enough that you'd risk using in production (at least w/in a group that is a little on the cutting-edge)? What things should a decent effect system support? Not only null checks I hope. (I was wondering about, via 'pilud' list, is how to rigorously handle immutable/mutable conversion/interaction.) Or are we just stuck with monads and related transformer boilerplate (and confusion to people like me)?</p>
<ul >
<li ><a href=\"http://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf\">Effects in Idris</a> (esoteric).</li>
<li ><a href=\"http://math.andrej.com/eff/\">Eff</a> (in progress, academic).</li>
<li ><a href=\"http://disciple.ouroborus.net/\">DDC</a> (rip).</li>
<li ><a href=\"http://lambda-the-ultimate.org/deca\">Deca</a> for pointers (limited).</li>
<li ><a href=\"http://homepages.inf.ed.ac.uk/slindley/papers/corelinks.pdf\">Links and DBs</a> (limited).</li>
<li ><a href=\"http://www.psrg.csail.mit.edu/history/publications/Papers/fx91-report.pdf\">FX-91</a> back in the day (rip).</li>
</ul>" nil nil "5fc82d0507db38d653e93e1123af5afe") (16 (20935 65033 761150) "http://lambda-the-ultimate.org/node/4767" "Are first-class environments enough?" nil "Fri, 21 Jun 2013 12:02:47 -0400" "<p >Everyone (e.g. in the <a href=\"/node/3861\">LtU discussion back from 2010</a>) seems to assume that first-class environments in a Scheme-like lexically scoped language are sufficient to implement all known module systems and then some. Still, it strikes me that implementing renaming of imported bindings (R[67]RS and Chicken <code >(rename)</code>, Racket <code >(rename-in)</code>) with just first-class environments is impossible <i >in the presence of mutability,</i> even if foreign code is forbidden from mutating things inside the module. Even <code >(only)</code>-style shadowing is impossible without built-in support specifically for it in addition to plain environment inheritance. Introducing all this into environment semantics makes the whole idea look much less clean than it initially did. So, is this better done with stronger things like first-class locations? Or am I missing something obvious?</p>
<p >There are suggestions that <a href=\"http://www.gnu.org/software/mit-scheme/\">MIT Scheme</a> indeed implements its module system using environments, but I couldn‚Äôt really understand how (and whether) it handles this issue. The description in the <a href=\"http://web.cs.wpi.edu/~jshutt/kernel.html\">Kernel</a> language report is the best reference I could get on the topic.</p>
<p >Finally, note that this question is orthogonal to whether mutating exported bindings is a good thing to do from the stylistic point of view. If a language has mutability and a module system, it‚Äôd better be consistent in how they interact ‚Äî a negative example here being the behaviour of bindings created with <code >from module import ...</code> in Python.</p>" nil nil "c64565b933694d1ad2170c63f953c46b") (15 (20928 8814 757820) "http://lambda-the-ultimate.org/node/4766" "Lobster, a new programming language, just released." nil "Mon, 17 Jun 2013 21:11:40 -0400" "<p >Lobster ( http://strlen.com/lobster ) has been released on GitHub ( https://github.com/aardappel/lobster ). It is a language that could be general purpose, but currently is specifically targeting game programming, with built-in support for OpenGL / SDL / FreeType. </p>
<p >The language looks similar to Python at first glance, but really is its own blend of fun features: a syntax centering around making higher order functions & function values look & function as much as possible like built-in control structures (terse, and with non-local returns), coroutines, multi-methods, vector operations, optional types, optional immutability.</p>
<p >The design did not have any lofty goals of programming language research or innovation, instead, it indulges in simply being a fun language for the typical code written in it (small-medium games).</p>" nil nil "eaf0e74863dcf37abc89f07ff9e697ff") (14 (20928 8814 757014) "http://lambda-the-ultimate.org/node/4765" "Library vs. domain specific language" nil "Mon, 17 Jun 2013 09:11:13 -0400" "<p >I guess this question was already discussed here on LtU, but I did not find it.</p>
<p >When is it necessary and rewarding to design a domain specific language, instead of creating a library for some general purpose language? Is it just more convenient syntax? What are the aspects that should be taken into account on deciding this question?</p>" nil nil "fb8d34ebd304f0bbc28f3cb088ca281f") (13 (20928 8814 756295) "http://lambda-the-ultimate.org/node/4764" "A New Kind of Type System" nil "Sat, 15 Jun 2013 22:15:53 -0400" "<p >I've been working on this <a href=\"http://mcdirmid.github.io/2013/06/14/a-new-kind-of-type-system/\">note</a> to describe the type system I've been working on that collects many of the ideas I've been working on (see <a href=\"http://lambda-the-ultimate.org/node/4431\">here</a>, <a href=\"http://lambda-the-ultimate.org/node/4493\">here</a> and <a href=\"\">here</a>, and <a href=\"http://lambda-the-ultimate.org/node/4660\">here</a>). Now that I actually have something fairly complete, feedback would be appreciated. I'm currently implementing this in my <a href=\"http://lambda-the-ultimate.org/node/4715\">live programming</a> work and it will hopefully be in my next prototype, though the ideas are relatively unrelated so far. Abstract:</p>
<blockquote ><p >
This note introduces a novel type system that is static, annotation free, and object-oriented with class-like mixin-style traits. Inference in this YinYang type system diverges significantly from Hindley-Milner by computing graphs of assignment relationships rather than principal types, hiding values and preserving connectivity in encapsulated graphs. Inferred types are then useful not only for checking purposes, but also in allowing code completion to specify program functionality in a relaxed order.
</p></blockquote>
<p >Again, the note is hosted <a href=\"http://mcdirmid.github.io/2013/06/14/a-new-kind-of-type-system/\">here</a> on GitHub.</p>" nil nil "cb0460c1ae25d1e6d2ce90aa659a5002") (12 (20928 8814 755334) "http://lambda-the-ultimate.org/node/4763" "a Scientific Basis for Visual Notations" nil "Fri, 14 Jun 2013 13:39:32 -0400" "<blockquote ><p >
<a href=\"http://www.ajilon.com.au/en-AU/news/Documents/News_PDFs/100528_Dr_Daniel_Moody_Software_Engineering_Keynote.pdf\">This paper [pdf]</a> defines a set of principles for designing cognitively effective visual notations.
</p></blockquote>
<p >(i'd quote more but i can't copy and paste and i'm already tired of typing.)</p>" nil nil "b0345eb73e52c1bbe1837e2f79feaa4c") (11 (20928 8814 754685) "http://lambda-the-ultimate.org/node/4762" "Compile-time constraint solver?" nil "Thu, 13 Jun 2013 13:31:10 -0400" "<p >C's type system can be seen as a constraint checker; Haskell's as a constraint solver. If you had a general purpose constraint solver at compile-time what could you use it for other than type checking?</p>" nil nil "476bbf37f17ac5d49702f873c72ca44f") (10 (20928 8814 753948) "http://lambda-the-ultimate.org/node/4761" "Define it twice -- preemptive bughunting or waste of time?" nil "Mon, 10 Jun 2013 20:38:05 -0400" "<p >Suppose I allow multiple definitions of routines/classes in a programming language, with the caveat that anything multiply defined must have identical semantics (identical interface, identical results, identical effects if non functional) and different syntactic structure in every definition. </p>
<p >Then have the development environment (but probably not the runtime environment) run multiple copies of the program, synchronizing just before and after each call to the multiply-implemented routine or class. If different results/effects are detected by a comparison of the program states at return time, halt with an error message.  Clearly, if both (or all) implementations are supposed to have the same semantics, then when results/effects diverge, it is evidence that at least one has a bug.</p>
<p >It seems unlikely, though possible, that both would have the same bugs, leading to rare \"false positives\" in which the test suite completes without error despite a lurking bug.   False negatives however -- where the test suite halts with a comparison error despite the tested code having identical semantics, would be eliminated.  Every time the alarm goes up, there is definitely something wrong. </p>
<p >Refactoring would also be easier; when a new implementation is supposed to provide the same services to the rest of the program as the old one, you could run them simultaneously rather than serially through a test suite, and make sure that, in fact, they do. This would also mean you can add test cases spontaneously and run them parallel, rather than having to reconfigure your program (twice!) to test both implementations against each other on a new test case you add/find after the first run of testing. </p>
<p >A semi-random thought about development environments.  More a programmer convenience, perhaps, since you could do the test and comparison by hand as well,  but nevertheless an important complement to static analysis.  It would allow you to test things well beyond the ability of a typical type analysis to make sure that they are and do, in fact, what you want. </p>
<p >Anyone seen something similar, or is this actually an original idea?</p>" nil nil "b8efd77c407d8798897ae67c2b6a31c9") (9 (20928 8814 752756) "http://lambda-the-ultimate.org/node/4760" "A little comparison of some programming lanugages" nil "Sun, 09 Jun 2013 17:47:21 -0400" "<blockquote ><p >
<a href=\"http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/\">This post</a> evaluates the programming languages ATS, C#, Go, Haskell, OCaml, Python and Rust to try to decide which would be the best language in which to write 0install (which is currently implemented in Python). Hopefully it will also be interesting to anyone curious about these languages.
</p></blockquote>
<p >i thought the <a href=\"http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#safety\">\"safety\" portion</a> of the evaluation was particularly interesting.</p>
<p >(overall, i find the review depressing: there's no good programming language, i guess.)</p>" nil nil "1fd22d245ef0a0689c446975ee9c5ec6") (8 (20928 8814 751709) "http://lambda-the-ultimate.org/node/4759" "So You are Thinking of Doing a PhD..." nil "Sun, 09 Jun 2013 11:11:53 -0400" "<p >On a lighthearted note, if you're considering pursuing a PhD you might want to take <a href=\"http://blog.prof.so/2013/06/test.html\">this simple test to see if you're a good candidate for this lifestyle.</p>" nil nil "f4db177d60f0892b573c033422ea5673") (7 (20928 8814 750858) "http://lambda-the-ultimate.org/node/4758" "A discussion from the trenches." nil "Sat, 08 Jun 2013 17:49:13 -0400" "<p >Over at lwn there is an currently a <a href=\"https://lwn.net/Articles/553131/\">discussion</a> going on about the little things in programming languages that make a difference.  Commas, decimal points, braces, etc. </p>
<p >The content is subscriber only for the first week so won't be generally available until the June 16th. </p>" nil nil "17b88924565850ab74064387f143a3c4") (6 (20928 8814 750028) "http://lambda-the-ultimate.org/node/4757" "CFP: ACM High Integrity Language Technology (HILT 2013) due June 29th; conference in Pittsburgh Nov. 10-14" nil "Thu, 06 Jun 2013 12:08:52 -0400" "<p >The deadline is June 29th (less than 4 weeks away) for submitting papers to the annual ACM conference on High Integrity Language Technology (HILT 2013).  The conference will be in Pittsburgh November 10-14, in close proximity to the Software Engineering Institute and CMU.  We have four great keynotes/invited speakers for this conference (Jeannette Wing, Ed Clarke, John Goodenough, and Michael Whalen), several interesting tutorials (on SMT solvers, Model Checking, etc.), and we are expecting some great papers as well (so get cracking!).  </p>
<p >Conference website is:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013\">http://www.sigada.org/conf/hilt2013</a></p>
<p >PDF Call for papers is at:</p>
<p >   <a href=\"http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf\">http://www.sigada.org/conf/hilt2013/HILT2013-CFP.pdf</a></p>
<p >-Tucker Taft<br >
Program Chair, HILT 2013</p>" nil nil "2d29035b6140d4eb010d9fb018f28c03") (5 (20928 8814 749193) "http://lambda-the-ultimate.org/node/4756" "Continuation calculus" nil "Tue, 04 Jun 2013 09:22:08 -0400" "<blockquote ><p >
Continuation calculus (\"CC\") is an alternative to lambda calculus, where the order of evaluation is determined by programs themselves. CC is a constrained term rewriting system, designed such that continuations are no unusual terms. This makes it natural to model programs with nonlocal control flow, as is the case with exceptions and call-by-name functions. The resulting system has very simple operational semantics.</p>
<p >Because no real pattern matching is possible in CC, we can only examine data through its reduction behavior. This in turn allows us to define values that are compatible to natural numbers or lists, but whose deconstruction requires computation. Such values are similar to call-by-name function applications.
</p></blockquote>
<p >For an introduction, look at the <a href=\"http://bgeron.nl/blog/continuation-calculus/\">presentation</a>. Details can be found in the <a href=\"http://bgeron.nl/cc-paper-current-draft.pdf\">paper</a>. You may also experiment with the <a href=\"http://bgeron.nl/cc-demo/\">online evaluator</a>, which has some example programs.</p>
<p >In future work, I will describe a scheme to translate functional programs to continuation calculus. I also plan to describe an applicable type system, but the details have yet to be worked out.</p>" nil nil "0e14cf8355dc52cb15d4ea029e781a51") (4 (20928 8814 748142) "http://lambda-the-ultimate.org/node/4755" "Primitive recursive functions and fixpoints" nil "Mon, 03 Jun 2013 12:52:59 -0400" "<p >In order to get a mathematical definition of recursive functions one needs fixpoints.</p>
<p >The following <a href=\"http://softwareverificaton.wordpress.com/2013/04/29/primitive-recursive-functions-and-fixpoints/\">article</a> describes how a certain class of recursive functions can be described via a functional whose fixpoint defines mathematically the recursive function. Furthermore it is shown that this class of recursive functions are defined via a unique fixpoints (i.e. the corresponding functional has only one fixpoint).</p>
<p >The article is based on the previous articles <a href=\"http://softwareverificaton.wordpress.com/2012/09/16/complete-lattices-and-closure-systems/\">Complete lattices and closure systems</a>, <a href=\"http://softwareverificaton.wordpress.com/2012/11/19/functions-and-complete-partial-orders/\">Functions and complete partial orders</a> and <a href=\"http://softwareverificaton.wordpress.com/2012/11/28/closures-and-fixpoints/\">Closures and fixpoints</a>.</p>" nil nil "091d7cc5af31606d47ea6669988570fa") (3 (20928 8814 747254) "http://lambda-the-ultimate.org/node/4753" "REScala: integrate reactive values with advanced event system" nil "Thu, 30 May 2013 18:17:08 -0400" "<p >Part of <a href=\"http://www.stg.tu-darmstadt.de/research/escala/index.en.jsp\">the EScala, REScala, JEScala</a> systems, a <a href=\"http://www.stg.tu-darmstadt.de/media/st/research/escala/REScala-report.pdf\">paper on REScala</a>:</p>
<blockquote ><p >
Traditionally, object-oriented software adopts the Observer pattern to implement reactive behavior. Its drawbacks are well-documented and two families of alternative approaches have been proposed, extending object-oriented languages with concepts from functional reactive and dataflow programming, respectively event-driven programming. The former hardly escape the functional setting; the latter do not achieve the declarativeness of more functional approaches. In this paper, we present RESCALA, a reactive language which integrates concepts from event-based and functional-reactive programming into the object-oriented world. RESCALA supports the development of reactive applications by fostering a functional declarative style which complements the advantages of object- oriented design.
</p></blockquote>
<p >There's example code available from the <a href=\"http://www.stg.tu-darmstadt.de/research/escala/index.en.jsp\">projects' web page</a>.</p>" nil nil "f1b00775acdee6335f828ec0775d32d1") (2 (20928 8814 746263) "http://lambda-the-ultimate.org/node/4752" "Computability Logic" nil "Tue, 28 May 2013 10:07:09 -0400" "<p >While not strictly related to programming languages, some people might be interested in <a href=\"http://www.cis.upenn.edu/~giorgi/cl.html\">Computability Logic</a>, which purports to generalize classical, linear and intuitionistic logics in a unified formal theory of computability. Brief overview:</p>
<blockquote ><p >Computation and computational problems in Computability Logic are understood in their most general, interactive sense, and are precisely seen as games played by a machine (computer, agent, robot) against its environment (user, nature, or the devil himself). Computability of such problems means existence of a machine that always wins the game. Logical operators stand for operations on computational problems, and validity of a logical formula means being a scheme of \"always computable\" problems. [...] The classical concept of truth is nothing but a special case of computability -- computability restricted to problems of zero interactivity degree.</p></blockquote>
<p >Looks like an interesting approach, and intuitively appealing, at least to me. Here's a link to the first paper <a href=\"http://www.csc.villanova.edu/~japaridz/ICL.pdf\">Introduction to computability logic</a>, by Giorgi Japaridze:</p>
<blockquote ><p >
This work is an attempt to lay foundations for a theory of interactive computation and bring logic and theory of computing closer together. It semantically introduces a logic of computability and sets a program for studying various aspects of that logic. The intuitive notion of (interactive) computational problems is formalized as a certain new, procedural-rule-free sort of games (called static games) between the machine and the environment, and computability is understood as existence of an interactive Turing machine that wins the game against any possible environment. The formalism used as a speciÔ¨Åcation language for computational problems, called the universal language, is a non-disjoint union of the formalisms of classical, intuitionistic and linear logics, with logical operators interpreted as certain, ‚Äî most basic and natural, ‚Äî operations on problems. Validity of a formula is understood as being ‚Äúalways computable‚Äù, and the set of all valid formulas is called the universal logic. The name ‚Äúuniversal‚Äù is related to the potential of this logic to integrate, on the basis of one semantics, classical, intuitionistic and linear logics, with their seemingly unrelated or even antagonistic philosophies. In particular, the classical notion of truth turns out to be nothing but computability restricted to the formulas of the classical fragment of the universal language, which makes classical logic a natural syntactic fragment of the universal logic. The same appears to be the case for intuitionistic and linear logics (understood in a broad sense and not necessarily identiÔ¨Åed with the particular known axiomatic systems). Unlike classical logic, these two do not have a good concept of truth, and the notion of computability restricted to the corresponding two fragments of the universal language, based on the intuitions that it formalizes, can well qualify as ‚Äúintuitionistic truth‚Äù and ‚Äúlinear-logic truth‚Äù. The paper also provides illustrations of potential applications of the universal logic in knowledgebase, resourcebase and planning systems, as well as constructive applied theories. The author has tried to make this article easy to read. It is fully self-contained and can be understood without any specialized knowledge of any particular subfield of logic or computer science.
</p></blockquote>
<p >Edit: I just realized there was an <a href=\"http://lambda-the-ultimate.org/node/204\">LtU post on this in the past</a> (and <a href=\"http://lambda-the-ultimate.org/node/1130\">another one</a>), but if you haven't seen it already, it's worth a look!</p>" nil nil "850579f0101e024bd7ece57eb90c9984") (1 (20928 8814 744211) "http://lambda-the-ultimate.org/node/4751" "DIALOG: A Conversational Programming System with a Graphical Orientation" nil "Sun, 26 May 2013 22:15:31 -0400" "<p >An old <a href=\"http://dl.acm.org/citation.cfm?id=363343\">paper</a> that seems quite retro by today's standards:</p>
<blockquote ><p >DIALOG is an algebraic language for online use with a graphical input-output console device. It is a computational aid for the casual user, which provides basic facilities for graphical and numeric input and display, online and offline program preparation and storage, and hard copy presentation of results. Use of the system requires a minimum of experience or instruction, since the growth of an overlaying system control language has been prevented, and there are no processor-oriented statements, like variable type or dimension declarations. Moreover, in the online situation the processor interacts with the graphical keyboard on a character-by-character basis so as to restrict the programmer's choice of input symbols to those which are syntactically correct. DIALOG has been in daily operation at the MIT Research Institute since February, 1966. </p></blockquote>
<p >The scanned paper is behind a paywall, but you can check <a href=\"https://skydrive.live.com/redir?resid=51C4267D41507773!395\">here</a>. </p>" nil nil "9e8dc83b989c7dd64793901ef8c10ff7")))